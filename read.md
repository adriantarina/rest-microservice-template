
## Documentation

The features are implemented within 3 microservices. The model has 2 base entities: report
and user, each being implemented into its own microservice, report-service and user-service
respectvely. The 3rd microservice aggregates data from the other two and returns through an
enpoint.

```
@Entity
@Table(name = "report")
public class Report {

    private @Id @GeneratedValue Long id;
    private String reportName;
    private Long submitterId;
    private Long ownerId;

    ... // getters, setters, all-argument constructor and no-argument constructor, equals and hashcode, toString
}

@Entity
@Table(name = "registered_user") // h2database complained when 'user' was used as a table name. This should be properly addressed if the DB selected has the same issue.
public class User {

    private @Id @GeneratedValue Long id;
    private String fullName;
    private Position position;

    ... // getters, setters, all-argument constructor and no-argument constructor, equals and hashcode, toString
}
```

[Documentation](https://linktodocumentation)

### REST endpoint with HATEOAS and autogenerated documentation

report-service contains the most complete example of a HATEOAS endpoint. 

The following maven dependencies are required:

```
<dependency> 
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
<dependency> <!-- spring-data-commons is the actual mandatory dependency required for pagination. In this example, spring-boot-starter-data-jpa includes the spring-data-commons dependency. -->
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency> <!-- h2database is an in-memory relation db. In real life, this will be replaced by the library required to interract with the DB -->
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency> <!-- next two dependencies are used for autodocumenting the endpoints. spring-doc is supposed to be the replacement of SWAGGER, which is no longer mainteined. It still uses SWAGGER-UI as a dependency.
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-ui</artifactId>
    <version>1.6.13</version>
</dependency>
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-hateoas</artifactId>
    <version>1.6.13</version>
</dependency>
```

At the data level, extending PagingAndSortingRepository interface (ReportRepository) provides CRUD operations with support for pagination will automatically be available.

At the controller level, we have two methods as example (get and list) which are implemented as @RestControllers.

```
@RestController
@RequestMapping(value = "/api/v1")
public class ReportController {

    @Autowired
    private ReportDao reportDao;

    @Autowired
    private ReportAssembler reportAssembler;

    @GetMapping(value = "/reports/{id}")
    public ResponseEntity<EntityModel<Report>> get(@PathVariable Long id) {
        Report report = reportDao.findById(id).orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "user not found"));
        return ResponseEntity.ok(reportAssembler.toModel(report));
    }
```

To support HATEOAS links, the response needs to be wrapped into ResponseEntity class and 
the EntityModel is the class actually holding the HATEOAS links. Thus, in our example, 
ResponseEntity<EntityModel<Report>> is the return type and reportAssembler is the class
helping to build the EntityModel instance.

```
@Component
public class ReportAssembler implements RepresentationModelAssembler<Report, EntityModel<Report>> {

    @Override
    public EntityModel<Report> toModel(Report report) {
        return EntityModel.of(report, linkTo(methodOn(ReportController.class).get(report.getId())).withSelfRel());
        // multiple links can be provided to the EntityModel.of() method, like edit and delete links, etc.
    }

}
```

And the JSON outputs:

```
{"id":2,"reportName":"username2","submitterId":1,"ownerId":2,"_links":{"self":{"href":"http://localhost:8082/api/v1/reports/2"}}}
```

ResponseStatusException is useful for handling any type of exception as spring has exception
handling which modifies the response header to return the status provided as argument. 

The list endpint is implemented as a spring @RestController.

```
@RestController
@RequestMapping(value = "/api/v1")
public class ReportController {

    @Autowired
    private ReportDao reportDao;

    @Autowired
    private PagedResourcesAssembler<Report> pagedResourcesAssembler;

    @Autowired
    private ReportAssembler reportAssembler;

    @GetMapping(value = "/reports")
    public ResponseEntity<PagedModel<EntityModel<Report>>> all(Pageable pageable) {

        Page<Report> reports = reportDao.findAll(pageable);

        return ResponseEntity.ok((pagedResourcesAssembler.toModel(reports, reportAssembler)));
    }
```

Notice that the Pageable argument is supported out-of-the-box by spring. As mentioned above,
PagingAndSortingRepository will auto generate CRUD operations with 
support for pagination. Notice that rahter than returning a collection, the findAll method
returns a Page<Report>. Also, the endpoint method returns ResponseEntity<PagedModel<EntityModel<Report>>>, 
where PageModel is used for storing paging data. PagedResourcesAssembler is a spring class that
creates a PagedModel given a Page instance and a RepresentationModelAssembler instance. 

The JSON output looks like this:
```
{
  "_embedded": {
    "reportList": [
      {
        "id": 1,
        "reportName": "Transaction Report",
        "submitterId": 1,
        "ownerId": 2,
        "_links": {
          "self": {
            "href": "http://localhost:8082/api/v1/reports/1"
          }
        }
      },
      {
        "id": 2,
        "reportName": "username2",
        "submitterId": 1,
        "ownerId": 2,
        "_links": {
          "self": {
            "href": "http://localhost:8082/api/v1/reports/2"
          }
        }
      }
    ]
  },
  "_links": {
    "self": {
      "href": "http://localhost:8082/api/v1/reports?page=0&size=20"
    }
  },
  "page": {
    "size": 20,
    "totalElements": 2,
    "totalPages": 1,
    "number": 0
  }
}
```
TODO: create links with all available paths

TODO: try generate HATEOAS links using spring-data-rest RepositoryEntityLinks

TODO: show case api-service where the data is built from two different endpoints rather than a DB and pagination needs to be implemented manually.

### REST client

### Metrics

### Logging